

Microchip MPLAB XC8 Assembler V2.32 build 20210201212658 
                                                                                                           Sat Jan 15 19:29:10 2022


     1                           	processor	18F25K42
     2                           	pagewidth 132
     3                           	psect	udata_acs,global,class=COMRAM,space=1,delta=1,lowdata,noexec
     4                           	psect	udata_bank0,global,class=BANK0,space=1,delta=1,lowdata,noexec
     5                           	psect	udata_bank1,global,class=BANK1,space=1,delta=1,lowdata,noexec
     6                           	psect	udata_bank2,global,class=BANK2,space=1,delta=1,lowdata,noexec
     7                           	psect	udata_bank3,global,class=BANK3,space=1,delta=1,lowdata,noexec
     8                           	psect	udata_bank4,global,class=BANK4,space=1,delta=1,lowdata,noexec
     9                           	psect	udata_bank5,global,class=BANK5,space=1,delta=1,lowdata,noexec
    10                           	psect	udata_bank6,global,class=BANK6,space=1,delta=1,lowdata,noexec
    11                           	psect	udata_bank7,global,class=BANK7,space=1,delta=1,lowdata,noexec
    12                           	psect	udata,global,class=RAM,space=1,delta=1,noexec
    13                           	psect	code,global,reloc=2,class=CODE,delta=1
    14                           	psect	data,global,reloc=2,class=CONST,delta=1,noexec
    15                           	psect	edata,global,class=EEDATA,space=3,delta=2,noexec
    16                           	psect	barfunc,local,reloc=2,class=CODE,delta=1
    17  0000                     
    18                           	psect	edata
    19  0000                     stk_offset	set	0
    20  0000                     auto_size	set	0
    21                           
    22                           ; stack_auto defines a symbol /name/_offset which equates to the
    23                           ; stack offset of the auto object in question
    24  000000                     
    25                           ; stack_param defines a symbol /name/_offset which equates to the
    26                           ; stack offset of the parameter object in question
    27  000000                     
    28                           ; alloc_stack adjusts the SP to allocate space for auto objects
    29                           ; it also links in to the btemp symbol so that can be used
    30  000000                     
    31                           ; restore_stack adjusts the SP to remove all auto and parameter
    32                           ; objects from the stack prior to returning from a function
    33  000000                     
    34                           ; Variables relating to bitgrabber incoming data
    35                           ; Variables relating to checking commands
    36                           ; Variables used to set up our bytepusher
    37                           ; Variables for outgoing responses, canned and assembled
    38                           ; External function
    39                           
    40                           	psect	barfunc
    41  000E0C                     _commandreader:
    42                           	callstack 0
    43                           
    44                           ; This function should run in the main loop.
    45                           ; When it detects that a stop bit has been written,
    46                           ; we can take action to quickly interpret the message
    47                           ; and send out the corresponding packet.
    48                           ; First let's check if the stop bit write flag is set
    49  000E0C  AE48               	btfss	_gInStatus,7,c	; Byte 7 in the status is the stop bit flag
    50  000E0E  0012               	return		; Return if there's no command to read
    51                           
    52                           ; WE WILL CLEAN UP LATER, JUST GET ON TO SENDING OUT THE RIGHT PACKS ASAP
    53                           ; Since the most high priority (performance-wise) command will be polling
    54                           ; which is where our button inputs are sent back, we should 100% check for this
    55                           ; first and foremost. We want as little delay as possible in polling as we have about
    56                           ; 600 MICROSECONDS to grab our button and stick updates before the next poll.
    57                           ; Less delay between poll command and our response means... more time for button updates =)
    58  000E10  013F               	movlb	63	; Switch to bank 0x3F
    59  000E12  9FD2               	bcf	210,7,b	; Stop global interrupts
    60  000E14  9F1F               	bcf	31,7,b	; Stop SMT
    61                           
    62                           ; Check to see if we have a poll command coming in
    63  000E16  0E60               	movlw	_gInPacket	; Get the address for our in packet
    64  000E18  006F FFA3 FFE9     	movff	wreg,fsr0l	; Copy our new pointer into FSR0. Access with INDF0
    65  000E1E  50EF               	movf	indf0,w,c
    66  000E20  1845               	xorwf	_gCommandPollMask,w,c	; Perform exclusive OR on the command byte against our mask
    67                           
    68                           ; If the mask is a match, the result will be 1111 1111. Incrementing this will produce 0.
    69                           ; Anything that ISN'T a match will fail the check zero/skip command.
    70  000E22  3CE8               	incfsz	wreg,w,c	; Increment and skip if it's zero.
    71  000E24  EF1D  F007         	goto	ORIGINPARSE	; We did not match, so now we check if it's an origin command.
    72                           
    73                           ; If we made it to here, we are working with a poll command.
    74                           ; Lets set up the outgoing byte as a pointer for the bytepush command.
    75  000E28  0E2F               	movlw	_gConPollPacket	; Get the pointer for the poll packet
    76  000E2A  6E2C               	movwf	_gConOutIdx,c	; Move the pointer into the outgoing index.
    77  000E2C  2AE9               	incf	fsr0l,f,c	; Increment the _gInPacket index twice to get to the byte with rumble
    78  000E2E  2AE9               	incf	fsr0l,f,c	;
    79  000E30  B0EF               	btfsc	indf0,0,c	; Test if the rumble bit is set, otherwise skip
    80  000E32  8848               	bsf	_gInStatus,4,c	; Set the rumble enable bit
    81  000E34  862D               	bsf	_gConByteCount,3,c	; Set our outgoing Byte count to 8 (bit set 3) 0000 1000
    82  000E36  8C48               	bsf	_gInStatus,6,c	; Mark that we have a valid command interpreted
    83  000E38  0012               	return	
    84  000E3A                     ORIGINPARSE:
    85  000E3A  50EF               	movf	indf0,w,c	; Copy our command byte data into WREG.
    86  000E3C  1846               	xorwf	_gCommandOriginMask,w,c	; Perform exclusive OR on the command byte against our mask
    87                           
    88                           ; If the mask is a match, the result will be 1111 1111. Incrementing this will produce 0.
    89                           ; Anything that ISN'T a match will fail the check zero/skip command.
    90  000E3E  3CE8               	incfsz	wreg,w,c	; Increment and skip if it's zero.
    91  000E40  EF28  F007         	goto	PROBEPARSE	; We did not match, so now we check if it's a probe command.
    92                           
    93                           ; If we made it to here, we are working with a origin command.
    94                           ; Lets set up the outgoing byte as a pointer for the bytepush command.
    95  000E44  0ED7               	movlw	_gConOriginResponse	; Get the pointer for the poll packet
    96  000E46  6E2C               	movwf	_gConOutIdx,c	; Move the pointer into the outgoing index.
    97  000E48  862D               	bsf	_gConByteCount,3,c	; Set our outgoing Byte count to 8 (bit set 3) 0000 1000
    98  000E4A  822D               	bsf	_gConByteCount,1,c	; Set the bit 1 so we have 10 (8+2) 0000 1010
    99  000E4C  8C48               	bsf	_gInStatus,6,c	; Mark that we have a valid command interpreted
   100  000E4E  0012               	return	
   101  000E50                     PROBEPARSE:
   102                           
   103                           ; First we can check if the command is 0x0 (0000 0000) meaning it's being probed.
   104  000E50  50EF               	movf	indf0,w,c
   105  000E52  66E8               	tstfsz	wreg,c	; If it's zero, skip checking any further
   106  000E54  EF33  F007         	goto	NOCOMMAND	; No command match
   107                           
   108                           ; We need to make sure our byte counter for outgoing is set
   109  000E58  802D               	bsf	_gConByteCount,0,c	; Set our outgoing Byte count to 1 (bit set 0) 0000 0001
   110  000E5A  822D               	bsf	_gConByteCount,1,c	; Set the bit 1 so we have 3 (1+2) 0000 0011
   111  000E5C  0EE1               	movlw	_gConProbeResponse	; Place the address for our first byte into WREG
   112  000E5E  6E2C               	movwf	_gConOutIdx,c	;
   113                           
   114                           ; Mark our status bit that we are synced
   115  000E60  8248               	bsf	_gInStatus,1,c	; Bit 1 is sync bit
   116  000E62  8C48               	bsf	_gInStatus,6,c	; Mark that we have a valid command interpreted
   117  000E64  0012               	return	
   118  000E66                     NOCOMMAND:
   119  000E66  8048               	bsf	_gInStatus,0,c	; Set bit 0 of our status flag meaning we need to resync
   120  000E68  0012               	return	
   121                           tosu	equ	0x3FFF
   122                           tosh	equ	0x3FFE
   123                           tosl	equ	0x3FFD
   124                           stkptr	equ	0x3FFC
   125                           pclatu	equ	0x3FFB
   126                           pclath	equ	0x3FFA
   127                           pcl	equ	0x3FF9
   128                           tblptru	equ	0x3FF8
   129                           tblptrh	equ	0x3FF7
   130                           tblptrl	equ	0x3FF6
   131                           tablat	equ	0x3FF5
   132                           prodh	equ	0x3FF4
   133                           prodl	equ	0x3FF3
   134                           indf0	equ	0x3FEF
   135                           postinc0	equ	0x3FEE
   136                           postdec0	equ	0x3FED
   137                           preinc0	equ	0x3FEC
   138                           plusw0	equ	0x3FEB
   139                           fsr0h	equ	0x3FEA
   140                           fsr0l	equ	0x3FE9
   141                           wreg	equ	0x3FE8
   142                           indf1	equ	0x3FE7
   143                           postinc1	equ	0x3FE6
   144                           postdec1	equ	0x3FE5
   145                           preinc1	equ	0x3FE4
   146                           plusw1	equ	0x3FE3
   147                           fsr1h	equ	0x3FE2
   148                           fsr1l	equ	0x3FE1
   149                           bsr	equ	0x3FE0
   150                           indf2	equ	0x3FDF
   151                           postinc2	equ	0x3FDE
   152                           postdec2	equ	0x3FDD
   153                           preinc2	equ	0x3FDC
   154                           plusw2	equ	0x3FDB
   155                           fsr2h	equ	0x3FDA
   156                           fsr2l	equ	0x3FD9
   157                           status	equ	0x3FD8


Microchip Technology PIC18 Macro Assembler V2.32 build 20210201212658 
Symbol Table                                                                                               Sat Jan 15 19:29:10 2022

                          FSR0 003FE9                            WREG 003FE8                           INDF0 003FEF  
                         _main 0A2E                     _gConOutIdx 002C                         isa$std 000001  
                    PROBEPARSE 0E50               _gCommandPollMask 0045                 _gConPollPacket 002F  
           _gCommandOriginMask 0046                _gInBitBufferIdx 002B              _gConProbeResponse 00E1  
                    _gInPacket 0060                      _gInStatus 0048                     ORIGINPARSE 0E3A  
                     NOCOMMAND 0E66                  _gConByteCount 002D                   _gInBitBuffer 0100  
                  _bytecleanup 1022             _gConOriginResponse 00D7                   _gInPacketIdx 0028  
                     _bytepush 057C                       isa$xinst 000000                  _commandreader 0E0C  
